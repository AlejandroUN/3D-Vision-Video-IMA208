# -*- coding: utf-8 -*-
"""circum_sphere

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YncydsXf5p5nAbBU8vn3qlouo82Y8f18
"""

import numpy as np
from scipy.spatial import Delaunay
from scipy.spatial import distance
from stl import mesh

# (3D)
# Open the file and read the vertices as strings
with open("bunny.xyz", "r") as f:
    vertex_strings = f.readlines()

# Convert the vertex strings to a NumPy array of shape (N, 3)
points3D = np.zeros((len(vertex_strings), 3))
for i, vertex_str in enumerate(vertex_strings):
    vertex_arr = [float(coord) for coord in vertex_str.strip().split()]
    points3D[i] = vertex_arr


tri = Delaunay(points3D)

# Preparing data for STL file
num_tetra = len(tri.simplices)
stl_mesh = mesh.Mesh(np.zeros(num_tetra, dtype=mesh.Mesh.dtype))

for tetra in tri.simplices:
    for k in range(len(tetra)):
        #print(points3D[tetra[k%4]],points3D[tetra[(k+1)%4]],points3D[tetra[(k+2)%4]])
        triangle = [ points3D[tetra[k%4]],points3D[tetra[(k+1)%4]],points3D[tetra[(k+2)%4]] ]

        #calculate the ecuclidians distances between the 3 points
        a = distance.euclidean(triangle[0], triangle[1])
        b = distance.euclidean(triangle[1], triangle[2])
        c = distance.euclidean(triangle[2], triangle[0])
        
        #calculate radius of circumcircle
        radius = (a*b*c) / np.sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) )

        if radius < 0.002:
            stl_mesh.vectors[tetra[k%4]] = triangle

# Write the mesh to file "output.stl"
stl_mesh.save('output.stl')